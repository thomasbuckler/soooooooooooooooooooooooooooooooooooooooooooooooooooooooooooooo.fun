<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vintage Typography Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            touch-action: none;
        }

        #editorWrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        #editorContainer {
            position: relative;
            cursor: text;
            background: #000;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #paperCanvas {
            display: block;
            width: auto;
            height: 100vh;
            max-width: 100vw;
        }

        #textCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #cursor {
            display: none;
        }
    </style>
</head>
<body>
    <div id="editorWrapper">
        <div id="editorContainer">
            <canvas id="paperCanvas"></canvas>
            <canvas id="textCanvas"></canvas>
            <div id="cursor"></div>
        </div>
    </div>

    <script>
        // Prevent zoom via keyboard and mouse
        document.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0')) {
                e.preventDefault();
            }
        });

        // EXACT DIMENSIONS WITH MARGINS
        const PAPER_WIDTH = 2172;
        const PAPER_HEIGHT = 3504;
        const MIN_CHAR_SPACING = -2;
        const MAX_CHAR_SPACING = 3;
        const MIN_VERTICAL_OFFSET = 0;
        const MAX_VERTICAL_OFFSET = 2;
        const MIN_SPACE_WIDTH = 22;
        const MAX_SPACE_WIDTH = 52;
        const SPACE_JITTER = 2;
        const MIN_LINE_HEIGHT = 80;
        const MAX_LINE_HEIGHT = 100;
        const BASELINE_HEIGHT = 60;
        const MARGIN_LEFT = 300;
        const MARGIN_RIGHT = 300;
        const MARGIN_TOP = 350;
        const MARGIN_BOTTOM = 400;
        const MAX_LINE_WIDTH = PAPER_WIDTH - MARGIN_RIGHT;
        const MAX_ALT_VARIANTS = 10;
        const RARE_VARIANT_CHANCE = 0.01;

        // Scale factor for display
        let displayScale = 1;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;

        // Ligature definitions - maps char pairs to ligature names
        const LIGATURES = {
            'fi': 'fi',
            'fl': 'fl',
            'ff': 'ff'
        };

        // Character-specific baseline offsets (positive = lower, negative = higher)
        const BASELINE_OFFSETS = {
            'g': 18,
            'p': 18,
            'j': 18,
            'y': 18,
            'q': 18,
            ',': 8,
            '.': 0,
            ':': 0,
            ';': 0,
            '!': 0,
            '?': 0,
            '-': -17,
            'openquote': -29,
            'closequote': -29,
            "'": -28,
            'fi': 0,
            'fl': 0,
            'ff': 0
        };

        // Character database with punctuation, quotes, and ligatures
        const charDatabase = {
            '0': { variants: [], rareVariants: [], loaded: false, baseFile: '0.png' },
            '1': { variants: [], rareVariants: [], loaded: false, baseFile: '1.png' },
            '7': { variants: [], rareVariants: [], loaded: false, baseFile: '7.png' },
            '8': { variants: [], rareVariants: [], loaded: false, baseFile: '8.png' },
            '9': { variants: [], rareVariants: [], loaded: false, baseFile: '9.png' },
            'A': { variants: [], rareVariants: [], loaded: false, baseFile: 'A1.png' },
            'B': { variants: [], rareVariants: [], loaded: false, baseFile: 'B1.png' },
            'C': { variants: [], rareVariants: [], loaded: false, baseFile: 'C1.png' },
            'D': { variants: [], rareVariants: [], loaded: false, baseFile: 'D1.png' },
            'E': { variants: [], rareVariants: [], loaded: false, baseFile: 'E1.png' },
            'F': { variants: [], rareVariants: [], loaded: false, baseFile: 'F1.png' },
            'G': { variants: [], rareVariants: [], loaded: false, baseFile: 'G1.png' },
            'H': { variants: [], rareVariants: [], loaded: false, baseFile: 'H1.png' },
            'I': { variants: [], rareVariants: [], loaded: false, baseFile: 'I1.png' },
            'J': { variants: [], rareVariants: [], loaded: false, baseFile: 'J1.png' },
            'K': { variants: [], rareVariants: [], loaded: false, baseFile: 'K1.png' },
            'L': { variants: [], rareVariants: [], loaded: false, baseFile: 'L1.png' },
            'M': { variants: [], rareVariants: [], loaded: false, baseFile: 'M1.png' },
            'N': { variants: [], rareVariants: [], loaded: false, baseFile: 'N1.png' },
            'O': { variants: [], rareVariants: [], loaded: false, baseFile: 'O1.png' },
            'P': { variants: [], rareVariants: [], loaded: false, baseFile: 'P1.png' },
            'Q': { variants: [], rareVariants: [], loaded: false, baseFile: 'Q1.png' },
            'R': { variants: [], rareVariants: [], loaded: false, baseFile: 'R1.png' },
            'S': { variants: [], rareVariants: [], loaded: false, baseFile: 'S1.png' },
            'T': { variants: [], rareVariants: [], loaded: false, baseFile: 'T1.png' },
            'U': { variants: [], rareVariants: [], loaded: false, baseFile: 'U1.png' },
            'V': { variants: [], rareVariants: [], loaded: false, baseFile: 'V1.png' },
            'W': { variants: [], rareVariants: [], loaded: false, baseFile: 'W1.png' },
            'X': { variants: [], rareVariants: [], loaded: false, baseFile: 'X1.png' },
            'Y': { variants: [], rareVariants: [], loaded: false, baseFile: 'Y1.png' },
            'Z': { variants: [], rareVariants: [], loaded: false, baseFile: 'Z1.png' },
            'a': { variants: [], rareVariants: [], loaded: false, baseFile: 'a2.png' },
            'b': { variants: [], rareVariants: [], loaded: false, baseFile: 'b2.png' },
            'c': { variants: [], rareVariants: [], loaded: false, baseFile: 'c2.png' },
            'd': { variants: [], rareVariants: [], loaded: false, baseFile: 'd2.png' },
            'e': { variants: [], rareVariants: [], loaded: false, baseFile: 'e2.png' },
            'f': { variants: [], rareVariants: [], loaded: false, baseFile: 'f2.png' },
            'g': { variants: [], rareVariants: [], loaded: false, baseFile: 'g2.png' },
            'h': { variants: [], rareVariants: [], loaded: false, baseFile: 'h2.png' },
            'i': { variants: [], rareVariants: [], loaded: false, baseFile: 'i2.png' },
            'j': { variants: [], rareVariants: [], loaded: false, baseFile: 'j2.png' },
            'k': { variants: [], rareVariants: [], loaded: false, baseFile: 'k2.png' },
            'l': { variants: [], rareVariants: [], loaded: false, baseFile: 'l2.png' },
            'm': { variants: [], rareVariants: [], loaded: false, baseFile: 'm2.png' },
            'n': { variants: [], rareVariants: [], loaded: false, baseFile: 'n2.png' },
            'o': { variants: [], rareVariants: [], loaded: false, baseFile: 'o2.png' },
            'p': { variants: [], rareVariants: [], loaded: false, baseFile: 'p2.png' },
            'q': { variants: [], rareVariants: [], loaded: false, baseFile: 'q2.png' },
            'r': { variants: [], rareVariants: [], loaded: false, baseFile: 'r2.png' },
            's': { variants: [], rareVariants: [], loaded: false, baseFile: 's2.png' },
            't': { variants: [], rareVariants: [], loaded: false, baseFile: 't2.png' },
            'u': { variants: [], rareVariants: [], loaded: false, baseFile: 'u2.png' },
            'v': { variants: [], rareVariants: [], loaded: false, baseFile: 'v2.png' },
            'w': { variants: [], rareVariants: [], loaded: false, baseFile: 'w2.png' },
            'x': { variants: [], rareVariants: [], loaded: false, baseFile: 'x2.png' },
            'y': { variants: [], rareVariants: [], loaded: false, baseFile: 'y2.png' },
            'z': { variants: [], rareVariants: [], loaded: false, baseFile: 'z2.png' },
            ',': { variants: [], rareVariants: [], loaded: false, baseFile: 'comma.png' },
            '.': { variants: [], rareVariants: [], loaded: false, baseFile: 'period.png' },
            ':': { variants: [], rareVariants: [], loaded: false, baseFile: 'colon.png' },
            ';': { variants: [], rareVariants: [], loaded: false, baseFile: 'semicolon.png' },
            '!': { variants: [], rareVariants: [], loaded: false, baseFile: 'exclamation.png' },
            '?': { variants: [], rareVariants: [], loaded: false, baseFile: 'question.png' },
            '-': { variants: [], rareVariants: [], loaded: false, baseFile: 'hyphen.png' },
            'openquote': { variants: [], rareVariants: [], loaded: false, baseFile: 'openquote.png' },
            'closequote': { variants: [], rareVariants: [], loaded: false, baseFile: 'closequote.png' },
            "'": { variants: [], rareVariants: [], loaded: false, baseFile: 'apostrophe.png' },
            'fi': { variants: [], rareVariants: [], loaded: false, baseFile: 'fi.png' },
            'fl': { variants: [], rareVariants: [], loaded: false, baseFile: 'fl.png' },
            'ff': { variants: [], rareVariants: [], loaded: false, baseFile: 'ff.png' },
            ' ': { variants: [], rareVariants: [], loaded: true, baseFile: null }
        };

        // Editor state
        let characters = [];
        let cursorIndex = 0;
        let currentX = MARGIN_LEFT;
        let currentBaseline = MARGIN_TOP;
        let currentLineSpaceWidth = MIN_SPACE_WIDTH + Math.random() * (MAX_SPACE_WIDTH - MIN_SPACE_WIDTH);
        let nextLineHeight = randomLineHeight();
        let quoteIsOpen = false;

        // Canvas references
        let paperCanvas, textCanvas, paperCtx, textCtx;
        let paperImage = new Image();
        let editorReady = false;

        function randomSpacing() {
            return MIN_CHAR_SPACING + Math.random() * (MAX_CHAR_SPACING - MIN_CHAR_SPACING);
        }

        function randomVerticalOffset() {
            return MIN_VERTICAL_OFFSET + Math.random() * (MAX_VERTICAL_OFFSET - MIN_VERTICAL_OFFSET);
        }

        function randomSpaceWidthForLine() {
            return MIN_SPACE_WIDTH + Math.random() * (MAX_SPACE_WIDTH - MIN_SPACE_WIDTH);
        }

        function applySpaceJitter(baseWidth) {
            return baseWidth + (Math.random() * SPACE_JITTER * 2 - SPACE_JITTER);
        }

        function randomLineHeight() {
            return MIN_LINE_HEIGHT + Math.random() * (MAX_LINE_HEIGHT - MIN_LINE_HEIGHT);
        }

        function randomVariant(char) {
            const charData = charDatabase[char];
            if (!charData) return null;

            if (Math.random() < RARE_VARIANT_CHANCE && charData.rareVariants.length > 0) {
                const randomIndex = Math.floor(Math.random() * charData.rareVariants.length);
                const variant = charData.rareVariants[randomIndex];
                console.log('✨ RARE variant used for:', char);
                return variant;
            }

            if (charData.variants.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * charData.variants.length);
            return charData.variants[randomIndex];
        }

        function getBaselineOffset(char) {
            return BASELINE_OFFSETS[char] || 0;
        }

        function updateQuoteState() {
            let openCount = 0;
            let closeCount = 0;

            for (let i = 0; i < characters.length; i++) {
                if (characters[i].quoteType === 'openquote') openCount++;
                if (characters[i].quoteType === 'closequote') closeCount++;
            }

            quoteIsOpen = openCount > closeCount;
        }

        function checkForLigature(char) {
            if (cursorIndex === 0) return null;

            const prevChar = characters[cursorIndex - 1];
            if (!prevChar || !prevChar.char) return null;

            if (prevChar.char === '\n' || prevChar.char === ' ') return null;

            const combination = prevChar.char + char;
            const ligatureName = LIGATURES[combination];

            if (ligatureName && charDatabase[ligatureName] && charDatabase[ligatureName].loaded) {
                console.log('Ligature detected:', combination, '→', ligatureName);
                return ligatureName;
            }

            return null;
        }

        function loadCharacterWithAlts(char) {
            const charData = charDatabase[char];
            if (!charData || !charData.baseFile) return;

            const baseName = charData.baseFile.replace('.png', '');
            const promises = [];

            const baseImg = new Image();
            const basePromise = new Promise((resolve, reject) => {
                baseImg.onload = () => {
                    charData.variants.push({
                        image: baseImg,
                        width: baseImg.naturalWidth,
                        height: baseImg.naturalHeight
                    });
                    console.log('Loaded ' + char + ':', baseImg.naturalWidth + 'x' + baseImg.naturalHeight);
                    resolve();
                };
                baseImg.onerror = () => {
                    console.log('Could not load:', charData.baseFile);
                    resolve();
                };
                baseImg.src = charData.baseFile;
            });
            promises.push(basePromise);

            for (let i = 1; i <= MAX_ALT_VARIANTS; i++) {
                const altFilename = baseName + '_alt' + i + '.png';
                const altImg = new Image();

                const altPromise = new Promise((resolve) => {
                    altImg.onload = () => {
                        charData.variants.push({
                            image: altImg,
                            width: altImg.naturalWidth,
                            height: altImg.naturalHeight
                        });
                        console.log('Loaded ' + char + ' alt' + i);
                        resolve();
                    };
                    altImg.onerror = () => resolve();
                    altImg.src = altFilename;
                });
                promises.push(altPromise);
            }

            const rareFilename = baseName + '_altRARE.png';
            const rareImg = new Image();
            const rarePromise = new Promise((resolve) => {
                rareImg.onload = () => {
                    charData.rareVariants.push({
                        image: rareImg,
                        width: rareImg.naturalWidth,
                        height: rareImg.naturalHeight
                    });
                    console.log('✨ Loaded ' + char + ' RARE variant');
                    resolve();
                };
                rareImg.onerror = () => resolve();
                rareImg.src = rareFilename;
            });
            promises.push(rarePromise);

            return Promise.all(promises).then(() => {
                charData.loaded = charData.variants.length > 0;
            });
        }

        async function loadImages() {
            await new Promise((resolve) => {
                paperImage.onload = () => resolve();
                paperImage.onerror = () => resolve();
                paperImage.src = 'blank1.jpg';
            });

            const charKeys = Object.keys(charDatabase).filter(k => k !== ' ');
            for (const char of charKeys) {
                await loadCharacterWithAlts(char);
            }

            setupCanvases();
            editorReady = true;
            console.log('Editor ready!');
        }

        function setupCanvases() {
            paperCanvas = document.getElementById('paperCanvas');
            textCanvas = document.getElementById('textCanvas');

            paperCanvas.width = PAPER_WIDTH;
            paperCanvas.height = PAPER_HEIGHT;
            textCanvas.width = PAPER_WIDTH;
            textCanvas.height = PAPER_HEIGHT;

            paperCtx = paperCanvas.getContext('2d');
            textCtx = textCanvas.getContext('2d');

            textCtx.imageSmoothingEnabled = false;
            paperCtx.imageSmoothingEnabled = false;

            paperCtx.drawImage(paperImage, 0, 0, PAPER_WIDTH, PAPER_HEIGHT);

            // Calculate display scale and position
            const displayHeight = paperCanvas.offsetHeight;
            const displayWidth = paperCanvas.offsetWidth;
            displayScale = displayHeight / PAPER_HEIGHT;

            const rect = paperCanvas.getBoundingClientRect();
            canvasOffsetX = rect.left;
            canvasOffsetY = rect.top;

            // Size text canvas to match display size
            textCanvas.style.width = displayWidth + 'px';
            textCanvas.style.height = displayHeight + 'px';

            updateCursorPosition();
        }

        function checkNeedWrap(x, width) {
            return x + width > MAX_LINE_WIDTH;
        }

        function addCharacter(char) {
            if (char === '\n') {
                const lineHeight = nextLineHeight;
                nextLineHeight = randomLineHeight();

                characters.splice(cursorIndex, 0, { 
                    char: '\n',
                    lineHeight: lineHeight
                });
                cursorIndex++;
                renderText();
                return;
            }

            if (char === ' ') {
                const spaceWidth = applySpaceJitter(currentLineSpaceWidth);
                characters.splice(cursorIndex, 0, { 
                    char: ' ', 
                    x: 0, 
                    width: spaceWidth 
                });
                cursorIndex++;
                renderText();
                return;
            }

            if (char === '"') {
                const quoteType = quoteIsOpen ? 'closequote' : 'openquote';
                const variant = randomVariant(quoteType);

                if (!variant) {
                    console.log('Quote character not loaded yet');
                    return;
                }

                const willWrap = checkNeedWrap(currentX, variant.width);

                if (willWrap) {
                    const lineHeight = nextLineHeight;
                    nextLineHeight = randomLineHeight();

                    characters.splice(cursorIndex, 0, { 
                        char: '\n',
                        lineHeight: lineHeight,
                        autoWrap: true
                    });
                    cursorIndex++;
                }

                const verticalOffset = randomVerticalOffset();
                const spacing = randomSpacing();
                const baselineOffset = getBaselineOffset(quoteType);

                characters.splice(cursorIndex, 0, {
                    char: '"',
                    quoteType: quoteType,
                    variant: variant,
                    x: 0,
                    y: 0,
                    width: variant.width,
                    height: variant.height,
                    baseline: 0,
                    verticalOffset: verticalOffset,
                    baselineOffset: baselineOffset,
                    spacing: spacing
                });

                quoteIsOpen = !quoteIsOpen;
                console.log('Added', quoteType, '- quote is now', quoteIsOpen ? 'OPEN' : 'CLOSED');

                cursorIndex++;
                renderText();
                return;
            }

            const ligatureName = checkForLigature(char);

            if (ligatureName) {
                const variant = randomVariant(ligatureName);
                if (!variant) return;

                characters.splice(cursorIndex - 1, 1);
                cursorIndex--;

                const willWrap = checkNeedWrap(currentX, variant.width);

                if (willWrap) {
                    const lineHeight = nextLineHeight;
                    nextLineHeight = randomLineHeight();

                    characters.splice(cursorIndex, 0, { 
                        char: '\n',
                        lineHeight: lineHeight,
                        autoWrap: true
                    });
                    cursorIndex++;
                }

                const verticalOffset = randomVerticalOffset();
                const spacing = randomSpacing();
                const baselineOffset = getBaselineOffset(ligatureName);

                characters.splice(cursorIndex, 0, {
                    char: ligatureName,
                    isLigature: true,
                    variant: variant,
                    x: 0,
                    y: 0,
                    width: variant.width,
                    height: variant.height,
                    baseline: 0,
                    verticalOffset: verticalOffset,
                    baselineOffset: baselineOffset,
                    spacing: spacing
                });

                cursorIndex++;
                renderText();
                return;
            }

            if (charDatabase[char] && charDatabase[char].loaded) {
                const variant = randomVariant(char);
                if (!variant) return;

                const willWrap = checkNeedWrap(currentX, variant.width);

                if (willWrap) {
                    const lineHeight = nextLineHeight;
                    nextLineHeight = randomLineHeight();

                    characters.splice(cursorIndex, 0, { 
                        char: '\n',
                        lineHeight: lineHeight,
                        autoWrap: true
                    });
                    cursorIndex++;
                }

                const verticalOffset = randomVerticalOffset();
                const spacing = randomSpacing();
                const baselineOffset = getBaselineOffset(char);

                characters.splice(cursorIndex, 0, {
                    char: char,
                    variant: variant,
                    x: 0,
                    y: 0,
                    width: variant.width,
                    height: variant.height,
                    baseline: 0,
                    verticalOffset: verticalOffset,
                    baselineOffset: baselineOffset,
                    spacing: spacing
                });

                cursorIndex++;
                renderText();
            }
        }

        function deleteCharacter() {
            if (cursorIndex > 0) {
                const deleted = characters[cursorIndex - 1];

                if (deleted.char === '"') {
                    characters.splice(cursorIndex - 1, 1);
                    cursorIndex--;
                    updateQuoteState();
                    renderText();
                } else {
                    characters.splice(cursorIndex - 1, 1);
                    cursorIndex--;
                    renderText();
                }
            }
        }

        function moveCursorLeft() {
            if (cursorIndex > 0) {
                cursorIndex--;
                updateCursorPosition();
            }
        }

        function moveCursorRight() {
            if (cursorIndex < characters.length) {
                cursorIndex++;
                updateCursorPosition();
            }
        }

        function moveCursorUp() {
            let targetX = currentX;
            let currentLine = 0;
            let charLineMap = [];

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;
            let line = 0;

            for (let i = 0; i < characters.length; i++) {
                charLineMap.push({ index: i, line: line, x: x, baseline: baseline });

                const c = characters[i];
                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    line++;
                } else if (c.char === ' ') {
                    x += c.width;
                } else {
                    x += c.width + c.spacing;
                }
            }

            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].index === cursorIndex - 1) {
                    currentLine = charLineMap[i].line;
                    targetX = charLineMap[i].x;
                    break;
                }
            }

            if (currentLine === 0) return;

            let closestIndex = 0;
            let minDist = Infinity;
            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].line === currentLine - 1) {
                    const dist = Math.abs(charLineMap[i].x - targetX);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIndex = charLineMap[i].index + 1;
                    }
                }
            }

            cursorIndex = closestIndex;
            updateCursorPosition();
        }

        function moveCursorDown() {
            let targetX = currentX;
            let currentLine = 0;
            let charLineMap = [];

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;
            let line = 0;

            for (let i = 0; i < characters.length; i++) {
                charLineMap.push({ index: i, line: line, x: x, baseline: baseline });

                const c = characters[i];
                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    line++;
                } else if (c.char === ' ') {
                    x += c.width;
                } else {
                    x += c.width + c.spacing;
                }
            }

            let maxLine = line;

            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].index === cursorIndex - 1) {
                    currentLine = charLineMap[i].line;
                    targetX = charLineMap[i].x;
                    break;
                }
            }

            if (currentLine >= maxLine) return;

            let closestIndex = characters.length;
            let minDist = Infinity;
            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].line === currentLine + 1) {
                    const dist = Math.abs(charLineMap[i].x - targetX);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIndex = charLineMap[i].index + 1;
                    }
                }
            }

            cursorIndex = closestIndex;
            updateCursorPosition();
        }

        function updateCursorPosition() {
            currentX = MARGIN_LEFT;
            currentBaseline = MARGIN_TOP;
            currentLineSpaceWidth = randomSpaceWidthForLine();

            for (let i = 0; i < cursorIndex; i++) {
                const c = characters[i];

                if (c.char === '\n') {
                    currentX = MARGIN_LEFT;
                    currentBaseline += c.lineHeight;
                    currentLineSpaceWidth = randomSpaceWidthForLine();
                } else if (c.char === ' ') {
                    currentX += c.width;
                } else {
                    currentX += c.width + c.spacing;
                }
            }

            updateCursor();
        }

        function renderText() {
            if (!textCtx) return;

            textCtx.clearRect(0, 0, PAPER_WIDTH, PAPER_HEIGHT);

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;

            for (let i = 0; i < characters.length; i++) {
                const c = characters[i];

                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    continue;
                }

                if (c.char === ' ') {
                    x += c.width;
                    continue;
                }

                if (c.variant && c.variant.image) {
                    const y = baseline - c.height + c.baselineOffset + c.verticalOffset;
                    textCtx.drawImage(c.variant.image, x, y, c.width, c.height);
                    x += c.width + c.spacing;
                }
            }

            updateCursorPosition();
        }

        function updateCursor() {
            // Cursor is now hidden, no need to update position
        }

        function handleKeyPress(e) {
            if (!editorReady) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                deleteCharacter();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                addCharacter('\n');
            } else if (e.key === ' ') {
                e.preventDefault();
                addCharacter(' ');
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveCursorLeft();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveCursorRight();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveCursorUp();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveCursorDown();
            } else if (e.key === '"') {
                e.preventDefault();
                addCharacter('"');
            } else if (e.key.length === 1) {
                if (charDatabase[e.key] && charDatabase[e.key].loaded) {
                    addCharacter(e.key);
                }
            }
        }

        document.getElementById('editorContainer').addEventListener('click', function() {
            document.body.focus();
        });

        document.addEventListener('keydown', handleKeyPress);

        loadImages();
    </script>
</body>
</html>