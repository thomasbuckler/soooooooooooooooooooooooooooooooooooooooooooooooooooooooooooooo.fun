<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage Typography Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #2a2a2a;
            overflow: auto;
        }

        #editorWrapper {
            display: flex;
            justify-content: center;
            padding: 20px;
            min-height: 100vh;
        }

        #editorContainer {
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            cursor: text;
            background: #000;
        }

        #paperCanvas {
            display: block;
        }

        #textCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #cursor {
            position: absolute;
            width: 2px;
            height: 60px;
            background: rgba(0,0,0,0.6);
            animation: blink 1s infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="editorWrapper">
        <div id="editorContainer">
            <canvas id="paperCanvas"></canvas>
            <canvas id="textCanvas"></canvas>
            <div id="cursor"></div>
        </div>
    </div>

    <script>
        // EXACT DIMENSIONS WITH MARGINS
        const PAPER_WIDTH = 2172;
        const PAPER_HEIGHT = 3504;
        const MIN_CHAR_SPACING = -3;
        const MAX_CHAR_SPACING = 3;
        const MIN_VERTICAL_OFFSET = 0;
        const MAX_VERTICAL_OFFSET = 3;
        const MIN_SPACE_WIDTH = 22;
        const MAX_SPACE_WIDTH = 52;
        const SPACE_JITTER = 2;
        const MIN_LINE_HEIGHT = 80;
        const MAX_LINE_HEIGHT = 100;
        const BASELINE_HEIGHT = 60;
        const MARGIN_LEFT = 300;
        const MARGIN_RIGHT = 300;
        const MARGIN_TOP = 450;
        const MARGIN_BOTTOM = 450;
        const MAX_LINE_WIDTH = PAPER_WIDTH - MARGIN_RIGHT;
        const MAX_ALT_VARIANTS = 20;
        const RARE_VARIANT_CHANCE = 0.001; // 1 in 100

        // Character database - now with regular and rare variants
        const charDatabase = {
            'A': { variants: [], rareVariants: [], loaded: false, baseFile: 'A1.png' },
            'a': { variants: [], rareVariants: [], loaded: false, baseFile: 'a2.png' },
            'b': { variants: [], rareVariants: [], loaded: false, baseFile: 'b2.png' },
            'D': { variants: [], rareVariants: [], loaded: false, baseFile: 'D1.png' },
            'd': { variants: [], rareVariants: [], loaded: false, baseFile: 'd2.png' },
            ' ': { variants: [], rareVariants: [], loaded: true, baseFile: null }
        };

        // Editor state
        let characters = [];
        let cursorIndex = 0;
        let currentX = MARGIN_LEFT;
        let currentBaseline = MARGIN_TOP;
        let currentLineSpaceWidth = MIN_SPACE_WIDTH + Math.random() * (MAX_SPACE_WIDTH - MIN_SPACE_WIDTH);
        let nextLineHeight = randomLineHeight();

        // Canvas references
        let paperCanvas, textCanvas, paperCtx, textCtx;
        let paperImage = new Image();
        let editorReady = false;

        // Random helper functions
        function randomSpacing() {
            return MIN_CHAR_SPACING + Math.random() * (MAX_CHAR_SPACING - MIN_CHAR_SPACING);
        }

        function randomVerticalOffset() {
            return MIN_VERTICAL_OFFSET + Math.random() * (MAX_VERTICAL_OFFSET - MIN_VERTICAL_OFFSET);
        }

        function randomSpaceWidthForLine() {
            return MIN_SPACE_WIDTH + Math.random() * (MAX_SPACE_WIDTH - MIN_SPACE_WIDTH);
        }

        function applySpaceJitter(baseWidth) {
            return baseWidth + (Math.random() * SPACE_JITTER * 2 - SPACE_JITTER);
        }

        function randomLineHeight() {
            return MIN_LINE_HEIGHT + Math.random() * (MAX_LINE_HEIGHT - MIN_LINE_HEIGHT);
        }

        function randomVariant(char) {
            const charData = charDatabase[char];
            if (!charData) return null;

            // 1% chance to use rare variant if available
            if (Math.random() < RARE_VARIANT_CHANCE && charData.rareVariants.length > 0) {
                const randomIndex = Math.floor(Math.random() * charData.rareVariants.length);
                const variant = charData.rareVariants[randomIndex];
                console.log('✨ RARE variant used for:', char);
                return variant;
            }

            // Otherwise use regular variants
            if (charData.variants.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * charData.variants.length);
            return charData.variants[randomIndex];
        }

        // Load character with alternatives and rare variants
        function loadCharacterWithAlts(char) {
            const charData = charDatabase[char];
            if (!charData || !charData.baseFile) return;

            const baseName = charData.baseFile.replace('.png', '');
            const promises = [];

            // Load base version
            const baseImg = new Image();
            const basePromise = new Promise((resolve, reject) => {
                baseImg.onload = () => {
                    charData.variants.push({
                        image: baseImg,
                        width: baseImg.naturalWidth,
                        height: baseImg.naturalHeight
                    });
                    console.log('Loaded ' + char + ' base:', baseImg.naturalWidth + 'x' + baseImg.naturalHeight);
                    resolve();
                };
                baseImg.onerror = () => reject();
                baseImg.src = charData.baseFile;
            });
            promises.push(basePromise);

            // Try to load regular alt variants
            for (let i = 1; i <= MAX_ALT_VARIANTS; i++) {
                const altFilename = baseName + '_alt' + i + '.png';
                const altImg = new Image();

                const altPromise = new Promise((resolve) => {
                    altImg.onload = () => {
                        charData.variants.push({
                            image: altImg,
                            width: altImg.naturalWidth,
                            height: altImg.naturalHeight
                        });
                        console.log('Loaded ' + char + ' alt' + i + ':', altImg.naturalWidth + 'x' + altImg.naturalHeight);
                        resolve();
                    };
                    altImg.onerror = () => resolve();
                    altImg.src = altFilename;
                });
                promises.push(altPromise);
            }

            // Try to load RARE variant
            const rareFilename = baseName + '_altRARE.png';
            const rareImg = new Image();
            const rarePromise = new Promise((resolve) => {
                rareImg.onload = () => {
                    charData.rareVariants.push({
                        image: rareImg,
                        width: rareImg.naturalWidth,
                        height: rareImg.naturalHeight
                    });
                    console.log('✨ Loaded ' + char + ' RARE variant:', rareImg.naturalWidth + 'x' + rareImg.naturalHeight);
                    resolve();
                };
                rareImg.onerror = () => resolve(); // Silent fail if no rare variant
                rareImg.src = rareFilename;
            });
            promises.push(rarePromise);

            return Promise.all(promises).then(() => {
                charData.loaded = charData.variants.length > 0;
            });
        }

        async function loadImages() {
            await new Promise((resolve) => {
                paperImage.onload = () => resolve();
                paperImage.onerror = () => resolve();
                paperImage.src = 'blank.jpg';
            });

            const charKeys = Object.keys(charDatabase).filter(k => k !== ' ');
            for (const char of charKeys) {
                await loadCharacterWithAlts(char);
            }

            setupCanvases();
            editorReady = true;

            console.log('\n=== CHARACTER SUMMARY ===');
            for (const char of charKeys) {
                const data = charDatabase[char];
                if (data.loaded) {
                    const rareInfo = data.rareVariants.length > 0 ? ' + ' + data.rareVariants.length + ' RARE' : '';
                    console.log(char + ': ' + data.variants.length + ' variant(s)' + rareInfo);
                }
            }
            console.log('Editor ready!');
        }

        function setupCanvases() {
            paperCanvas = document.getElementById('paperCanvas');
            textCanvas = document.getElementById('textCanvas');

            paperCanvas.width = PAPER_WIDTH;
            paperCanvas.height = PAPER_HEIGHT;
            textCanvas.width = PAPER_WIDTH;
            textCanvas.height = PAPER_HEIGHT;

            paperCtx = paperCanvas.getContext('2d');
            textCtx = textCanvas.getContext('2d');

            textCtx.imageSmoothingEnabled = false;
            paperCtx.imageSmoothingEnabled = false;

            paperCtx.drawImage(paperImage, 0, 0, PAPER_WIDTH, PAPER_HEIGHT);

            updateCursorPosition();
        }

        function checkNeedWrap(x, width) {
            return x + width > MAX_LINE_WIDTH;
        }

        function addCharacter(char) {
            if (char === '\n') {
                const lineHeight = nextLineHeight;
                nextLineHeight = randomLineHeight();

                characters.splice(cursorIndex, 0, { 
                    char: '\n',
                    lineHeight: lineHeight
                });
                cursorIndex++;
                renderText();
                return;
            }

            if (char === ' ') {
                const spaceWidth = applySpaceJitter(currentLineSpaceWidth);
                characters.splice(cursorIndex, 0, { 
                    char: ' ', 
                    x: 0, 
                    width: spaceWidth 
                });
                cursorIndex++;
                renderText();
                return;
            }

            if (charDatabase[char] && charDatabase[char].loaded) {
                const variant = randomVariant(char);
                if (!variant) return;

                const willWrap = checkNeedWrap(currentX, variant.width);

                if (willWrap) {
                    const lineHeight = nextLineHeight;
                    nextLineHeight = randomLineHeight();

                    characters.splice(cursorIndex, 0, { 
                        char: '\n',
                        lineHeight: lineHeight,
                        autoWrap: true
                    });
                    cursorIndex++;
                }

                const verticalOffset = randomVerticalOffset();
                const spacing = randomSpacing();

                characters.splice(cursorIndex, 0, {
                    char: char,
                    variant: variant,
                    x: 0,
                    y: 0,
                    width: variant.width,
                    height: variant.height,
                    baseline: 0,
                    verticalOffset: verticalOffset,
                    spacing: spacing
                });

                cursorIndex++;
                renderText();
            }
        }

        function deleteCharacter() {
            if (cursorIndex > 0) {
                characters.splice(cursorIndex - 1, 1);
                cursorIndex--;
                renderText();
            }
        }

        function moveCursorLeft() {
            if (cursorIndex > 0) {
                cursorIndex--;
                updateCursorPosition();
            }
        }

        function moveCursorRight() {
            if (cursorIndex < characters.length) {
                cursorIndex++;
                updateCursorPosition();
            }
        }

        function moveCursorUp() {
            let targetX = currentX;
            let currentLine = 0;
            let charLineMap = [];

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;
            let line = 0;

            for (let i = 0; i < characters.length; i++) {
                charLineMap.push({ index: i, line: line, x: x, baseline: baseline });

                const c = characters[i];
                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    line++;
                } else if (c.char === ' ') {
                    x += c.width;
                } else {
                    x += c.width + c.spacing;
                }
            }

            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].index === cursorIndex - 1) {
                    currentLine = charLineMap[i].line;
                    targetX = charLineMap[i].x;
                    break;
                }
            }

            if (currentLine === 0) return;

            let closestIndex = 0;
            let minDist = Infinity;
            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].line === currentLine - 1) {
                    const dist = Math.abs(charLineMap[i].x - targetX);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIndex = charLineMap[i].index + 1;
                    }
                }
            }

            cursorIndex = closestIndex;
            updateCursorPosition();
        }

        function moveCursorDown() {
            let targetX = currentX;
            let currentLine = 0;
            let charLineMap = [];

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;
            let line = 0;

            for (let i = 0; i < characters.length; i++) {
                charLineMap.push({ index: i, line: line, x: x, baseline: baseline });

                const c = characters[i];
                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    line++;
                } else if (c.char === ' ') {
                    x += c.width;
                } else {
                    x += c.width + c.spacing;
                }
            }

            let maxLine = line;

            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].index === cursorIndex - 1) {
                    currentLine = charLineMap[i].line;
                    targetX = charLineMap[i].x;
                    break;
                }
            }

            if (currentLine >= maxLine) return;

            let closestIndex = characters.length;
            let minDist = Infinity;
            for (let i = 0; i < charLineMap.length; i++) {
                if (charLineMap[i].line === currentLine + 1) {
                    const dist = Math.abs(charLineMap[i].x - targetX);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIndex = charLineMap[i].index + 1;
                    }
                }
            }

            cursorIndex = closestIndex;
            updateCursorPosition();
        }

        function updateCursorPosition() {
            currentX = MARGIN_LEFT;
            currentBaseline = MARGIN_TOP;
            currentLineSpaceWidth = randomSpaceWidthForLine();

            for (let i = 0; i < cursorIndex; i++) {
                const c = characters[i];

                if (c.char === '\n') {
                    currentX = MARGIN_LEFT;
                    currentBaseline += c.lineHeight;
                    currentLineSpaceWidth = randomSpaceWidthForLine();
                } else if (c.char === ' ') {
                    currentX += c.width;
                } else {
                    currentX += c.width + c.spacing;
                }
            }

            updateCursor();
        }

        function renderText() {
            if (!textCtx) return;

            textCtx.clearRect(0, 0, PAPER_WIDTH, PAPER_HEIGHT);

            let x = MARGIN_LEFT;
            let baseline = MARGIN_TOP;

            for (let i = 0; i < characters.length; i++) {
                const c = characters[i];

                if (c.char === '\n') {
                    x = MARGIN_LEFT;
                    baseline += c.lineHeight;
                    continue;
                }

                if (c.char === ' ') {
                    x += c.width;
                    continue;
                }

                if (c.variant && c.variant.image) {
                    const y = baseline - c.height + c.verticalOffset;
                    textCtx.drawImage(c.variant.image, x, y, c.width, c.height);
                    x += c.width + c.spacing;
                }
            }

            updateCursorPosition();
        }

        function updateCursor() {
            const cursor = document.getElementById('cursor');
            cursor.style.left = currentX + 'px';
            cursor.style.top = (currentBaseline - BASELINE_HEIGHT) + 'px';
        }

        function handleKeyPress(e) {
            if (!editorReady) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                deleteCharacter();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                addCharacter('\n');
            } else if (e.key === ' ') {
                e.preventDefault();
                addCharacter(' ');
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveCursorLeft();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveCursorRight();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveCursorUp();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveCursorDown();
            } else if (e.key.length === 1) {
                if (charDatabase[e.key] && charDatabase[e.key].loaded) {
                    addCharacter(e.key);
                }
            }
        }

        document.getElementById('editorContainer').addEventListener('click', function() {
            document.body.focus();
        });

        document.addEventListener('keydown', handleKeyPress);

        loadImages();
    </script>
</body>
</html>